//  MIT License
//
//  Copyright (c) 2023 Ronald van Wijnen
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef SPECTRAL
#define SPECTRAL

const int SPECTRAL_SIZE = 37;
const float SPECTRAL_GAMMA = 2.4;
const float SPECTRAL_EPSILON = 0.01;

const float SPD_RED[SIZE] = float[SIZE](
    0.03065266, 0.03065266, 0.03012503, 0.0283744, 0.02443079, 0.01900359, 0.01345743, 0.00905147, 0.00606943, 0.0041924, 0.00300621, 0.00229452, 0.00190474, 0.00175435,
    0.00182349, 0.00218287, 0.00308472, 0.00539517, 0.01275154, 0.04939664, 0.41424516, 0.89425217, 0.95202201, 0.96833286, 0.97175685, 0.97320302, 0.97387285, 0.97418395,
    0.97432335, 0.97432335, 0.97432335, 0.97432335, 0.97432335, 0.97432335, 0.97432335, 0.97432335, 0.97432335
);

const float SPD_GREEN[SIZE] = float[SIZE](
    0.00488428, 0.00488428, 0.00489302, 0.00505932, 0.00552416, 0.00668451, 0.00966823, 0.01843871, 0.05369084, 0.30997719, 0.84166297, 0.95140393, 0.97711658, 0.98538119,
    0.98819579, 0.98842729, 0.98651266, 0.98125477, 0.96796653, 0.9212632, 0.54678757, 0.07097922, 0.02151275, 0.01120932, 0.00778212, 0.00633303, 0.00566048, 0.00534751,
    0.00520568, 0.00520568, 0.00520568, 0.00520568, 0.00520568, 0.00520568, 0.00520568, 0.00520568, 0.00520568
);

const float SPD_BLUE[SIZE] = float[SIZE](
    0.96446343, 0.96446661, 0.96499804, 0.96660443, 0.97009698, 0.97438902, 0.97695626, 0.97257598, 0.94029002, 0.68585683, 0.1553392, 0.04629964, 0.02096763, 0.01284767,
    0.00996131, 0.00937163, 0.01038752, 0.0133401, 0.01927821, 0.02934328, 0.03897609, 0.03478168, 0.02647979, 0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109,
    0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109, 0.02047109
);

const float CIE_CMF_X[SIZE] = float[SIZE](
    0.00013656, 0.00131637, 0.00640948, 0.01643026, 0.02407799, 0.03573573, 0.03894236, 0.03004572, 0.0186094, 0.0074502, 0.00129006, 0.00052314, 0.00344737, 0.01065677,
    0.02169564, 0.03395004, 0.04732762, 0.06029657, 0.07284094, 0.08385845, 0.08612109, 0.08746894, 0.07951403, 0.06405614, 0.04521591, 0.03062648, 0.01838938, 0.0104432,
    0.00576692, 0.00279715, 0.00119535, 0.00059496, 0.00029365, 0.000115, 0.00006279, 0.00003275, 0.00001376
);

const float CIE_CMF_Y[SIZE] = float[SIZE](
    0.00001886, 0.0001814, 0.00080632, 0.00203723, 0.00344701, 0.00662872, 0.01029015, 0.01410577, 0.0194424, 0.02631783, 0.03273183, 0.04424704, 0.057012, 0.06907721, 0.08047999,
    0.08541136, 0.08725039, 0.08416902, 0.07860677, 0.07114656, 0.0590749, 0.05050107, 0.04005938, 0.02932589, 0.01939909, 0.01258803, 0.00734245, 0.00409671, 0.00223674,
    0.00107927, 0.00046015, 0.00022887, 0.000113, 0.00004432, 0.00002425, 0.00001268, 0.00000535
);

const float CIE_CMF_Z[SIZE] = float[SIZE](
    0.00060998, 0.00595953, 0.02967913, 0.07855475, 0.11921905, 0.18425721, 0.21077492, 0.1763428, 0.12741269, 0.0737491, 0.03663768, 0.01923495, 0.00807728, 0.00335702,
    0.00140323, 0.00053757, 0.00020463, 0.00007431, 0.00002725, 0.00001053, 0.00000391, 0.00000166, 0.00000072, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0
);

const mat3 XYZ_RGB = mat3(
    vec3( 3.24096994, -1.53738318, -0.49861076),
    vec3(-0.96924364,  1.87596750,  0.04155506),
    vec3( 0.05563008, -0.20397696,  1.05697151)
);

const mat3 RGB_XYZ = mat3(
    vec3(0.41239080, 0.35758434, 0.18048079),
    vec3(0.21263901, 0.71516868, 0.07219232),
    vec3(0.01933082, 0.11919478, 0.95053215)
);

float spectral_uncompand(float x) {
  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);
}

float spectral_compand(float x) {
  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;
}

vec3 spectral_srgb_to_linear(vec3 srgb) {
    return vec3(spectral_uncompand(srgb[0] + SPECTRAL_EPSILON), spectral_uncompand(srgb[1] + SPECTRAL_EPSILON), spectral_uncompand(srgb[2] + SPECTRAL_EPSILON));
}

vec3 spectral_linear_to_srgb(vec3 lrgb) {
    return clamp(vec3(spectral_compand(lrgb[0] - SPECTRAL_EPSILON), spectral_compand(lrgb[1] - SPECTRAL_EPSILON), spectral_compand(lrgb[2] - SPECTRAL_EPSILON)), 0.0, 1.0);
}

void spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {
    for (int i = 0; i < SPECTRAL_SIZE; i++) {
      R[i] = dot(vec3(SPECTRAL_SPD_RED[i], SPECTRAL_SPD_GREEN[i], SPECTRAL_SPD_BLUE[i]), lrgb);
    }
}

vec3 spectral_xyz_to_srgb(vec3 xyz) {
    float r = dot(SPECTRAL_XYZ_RGB[0], xyz);
    float g = dot(SPECTRAL_XYZ_RGB[1], xyz);
    float b = dot(SPECTRAL_XYZ_RGB[2], xyz);

    return spectral_linear_to_srgb(vec3(r, g, b));
}

vec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {
    vec3 xyz;

    for (int i = 0; i < SPECTRAL_SIZE; i++) {
      xyz[0] += dot(R[i], SPECTRAL_CIE_CMF_X[i]);
      xyz[1] += dot(R[i], SPECTRAL_CIE_CMF_Y[i]);
      xyz[2] += dot(R[i], SPECTRAL_CIE_CMF_Z[i]);
    }

    return xyz;
}

float spectral_linear_to_concentration(float l1, float l2, float t) {
    float t1 = l1 * pow(1.0 - t, 2.0);
    float t2 = l2 * pow(t, 2.0);

    return t2 / (t1 + t2);
}

float spectral_luminance(vec3 color) {
    return dot(SPECTRAL_RGB_XYZ[1], color);
}

vec3 spectral_mix(vec3 color1, vec3 color2, float t) {
    vec3 lrgb1 = spectral_srgb_to_linear(color1);
    vec3 lrgb2 = spectral_srgb_to_linear(color2);

    float l1 = spectral_luminance(lrgb1);
    float l2 = spectral_luminance(lrgb2);

    t = spectral_linear_to_concentration(l1, l2, t);

    float R1[SPECTRAL_SIZE];
    float R2[SPECTRAL_SIZE];

    spectral_linear_to_reflectance(lrgb1, R1);
    spectral_linear_to_reflectance(lrgb2, R2);

    float R[SPECTRAL_SIZE];

    for (int i = 0; i < SPECTRAL_SIZE; i++) {
      float KS = 0.0;

      KS += (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i]));
      KS += t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));

      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);

      //Saunderson correction
      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);

      R[i] = KM;
    }

    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));
}

vec4 spectral_mix(vec4 color1, vec4 color2, float t) {
    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));
}

#endif